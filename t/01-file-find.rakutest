use Test;
use File::Find;

plan 29;

my $res = find(:dir<t/dir1>);
my @test = $res.map({ .Str }).sort;
equals @test, <t/dir1/another_dir t/dir1/another_dir/empty_file t/dir1/another_dir/file.bar t/dir1/file.bar t/dir1/file.foo t/dir1/foodir t/dir1/foodir/not_a_dir>, 'just a dir';

# names

$res = find(:dir<t/dir1>, :name(/foo/));
@test = $res.map({ .Str }).sort;
equals @test, <t/dir1/file.foo t/dir1/foodir>, 'name with regex';

# (default) recursive find

$res = find(:dir<t/dir1>, :name<file.bar>);
is $res.elems, 2, 'two files with name and string';

# with forced find to Not work recursive

$res = find(:dir<t/dir1>, :name<file.bar>, recursive => False);
is $res.elems, 1, 'name with a string';

$res = find(:dir<t/dir1>, :name<notexisting>);
is $res.elems, 0, 'no results';

# types

$res = find(:dir<t/dir1>, :type<dir>);
@test = $res.map({ .Str }).sort;
equals @test, <t/dir1/another_dir t/dir1/foodir>, 'types: dir';

$res = find(:dir<t/dir1>, :type<dir>, :name(/foo/));
@test = $res.map({ .Str }).sort;
equals @test, <t/dir1/foodir>, 'types: dir, combined with name';

$res = find(:dir<t/dir1>, :type<file>, :name(/foo/));
@test = $res.map({ .Str }).sort;
equals @test, <t/dir1/file.foo>,
        'types: file, combined with name';

#exclude
$res = find(:dir<t/dir1>, :type<file>,
            :exclude('t/dir1/another_dir'.IO));
@test = $res.map({ .Str }).sort;
equals @test, <t/dir1/file.bar t/dir1/file.foo t/dir1/foodir/not_a_dir>, 'exclude works';

# exclude with junction 
$res = find(:dir<t/dir1>, :type<file>, :exclude( any(/\.foo/, /\.bar/) ));
@test = $res.map({ .Str }).sort;
isnt( @test[0].^name, 'Junction', "Return from find should not be a Junction" );
equals @test, < t/dir1/another_dir/empty_file  t/dir1/foodir/not_a_dir >, 'exclude with junction';

# name with junction 
$res = find(:dir<t/dir1>, :name( any(/\.foo/, /\.bar/) ));
@test = $res.map({ .Str }).sort;
isnt( @test[0].^name, 'Junction', "Return from find should not be a Junction" );
equals @test, < t/dir1/another_dir/file.bar t/dir1/file.bar t/dir1/file.foo >, 'name with junction';

# symlink
@test = find(:dir<t/dir1>, :type<symlink>);
is $@test.elems, 0, 'lives and no symlinks found';

# wrong type
dies-ok { find(:dir<t/dir1>, :type<foo>) }, "dies on incorrect type";

# keep-going
my $skip-first = True;
my $throw = True;

# follow-symlinks
my $symlink-dir := $*PROGRAM.sibling("dir2/symdir");
symlink($*PROGRAM.sibling("dir1/another_dir"), $symlink-dir);
if $symlink-dir.e {
    $res = find(:dir<t/dir2>);
    @test = $res.map({ .Str }).sort;
    equals @test,
      <t/dir2/file.foo t/dir2/symdir t/dir2/symdir/empty_file t/dir2/symdir/file.bar>,
      'follow-syminks is True';

    $res = find(:dir<t/dir2>, :!follow-symlinks);
    @test = $res.map({ .Str }).sort;
    equals @test,
      <t/dir2/file.foo t/dir2/symdir>,
      'follow-symlinks is False';

    unlink $symlink-dir;  # cleanup for the next test run, just in case
}

else {
    pass "Cannot check symlinks on dirs in this OS" for ^2;
}

# Wrap dir to throw when we want it to.
my $w = &dir.wrap(sub ($_) {
    if $skip-first {
         $skip-first = False;
         return callsame;
    }

    if $throw {
        $throw = False;
        X::IO::Dir.new(path => "dummy", os-error => "dummy").throw
    }
    callsame;
});

dies-ok(sub { find(:dir<t/dir1>) },
    "dies due to X::IO::Dir");

$throw = $skip-first = True;
$res = find(:dir<t/dir1>, :name<file.bar>, keep-going => True);
is $res.elems, 1, 'found one of two files due to X::IO::Dir';

sub equals(\a, \b, $name) {
    my $is-ok = is a.elems, b.elems, a ~ " and " ~ b ~ " have the same length ";
    ok ([&&] a >>~~<< b.map(*.IO)), $name if $is-ok;
}

# vim: expandtab shiftwidth=4
